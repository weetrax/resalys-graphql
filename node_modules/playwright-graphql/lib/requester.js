"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSdkRequester = getSdkRequester;
const graphql_1 = require("graphql");
require("json-bigint-patch");
const defaultOptions = { gqlEndpoint: '/api/graphql', rawResponse: false };
const operationDefinition = 'OperationDefinition';
const subscription = 'subscription';
const validDocDefOps = ['mutation', 'query', subscription];
const returnRawResponseStrategy = async (response) => {
    try {
        return (await response.json());
    }
    catch (e) {
        throw new Error(await buildMessage(e, response));
    }
};
const returnDataResponseStrategy = async (response, options) => {
    let json;
    try {
        json = await response.json();
    }
    catch (e) {
        throw new Error(await buildMessage(e, response));
    }
    if (options?.returnRawJson) {
        return json;
    }
    if ([undefined, null].includes(json.data)) {
        const failOnEmptyData = options?.failOnEmptyData ?? true;
        if (!failOnEmptyData) {
            return json;
        }
        const formattedJsonString = JSON.stringify(JSON.parse(await response.text()), null, '  ');
        throw new Error(`No data presented in the GraphQL response: ${formattedJsonString}`);
    }
    return json.data;
};
function doPostRequest(requestParams) {
    return requestParams.client.post(requestParams.gqlEndpoint, {
        ...requestParams.options,
        data: { variables: requestParams.variables, query: (0, graphql_1.print)(requestParams.doc) },
    });
}
function initRequest(requestHandler) {
    return requestHandler ?
        (requestParams) => requestHandler(() => doPostRequest(requestParams)) :
        (requestParams) => doPostRequest(requestParams);
}
function getSdkRequester(client, options = defaultOptions, requestHandler) {
    const requesterOptions = {
        ...defaultOptions,
        ...(typeof options === 'string' ? { gqlEndpoint: options } : options)
    };
    const doRequest = initRequest(requestHandler);
    return requesterOptions.rawResponse ?
        async (doc, variables, options) => {
            validateDocument(doc);
            const request = doRequest({ client, gqlEndpoint: requesterOptions.gqlEndpoint, variables, doc, options });
            const response = await request;
            return returnRawResponseStrategy(response);
        }
        :
            async (doc, variables, options) => {
                validateDocument(doc);
                const request = doRequest({ client, gqlEndpoint: requesterOptions.gqlEndpoint, variables, doc, options });
                const response = await request;
                return returnDataResponseStrategy(response, options);
            };
}
function validateDocument(doc) {
    // Valid document should contain *single* query or mutation unless it's has a fragment
    if (doc.definitions.filter((d) => d.kind === operationDefinition && validDocDefOps.includes(d.operation)).length !== 1) {
        throw new Error('DocumentNode passed to Playwright Client must contain single query or mutation');
    }
    const definition = doc.definitions[0];
    // Valid document should contain *OperationDefinition*
    if (definition.kind !== operationDefinition) {
        throw new Error('DocumentNode passed to Playwright must contain single query or mutation');
    }
    if (definition.operation === subscription) {
        throw new Error('Subscription requests through SDK interface are not supported');
    }
}
async function buildMessage(e, response) {
    return `${e.message}
                \nStatus code: ${response.status()}
                \nHeaders: ${JSON.stringify(response.headers())}
                \nResponse body is not a json but: ${await response.text()}`;
}
