#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const run_command_1 = require("./run-command");
const fs = __importStar(require("fs"));
const promises_1 = require("fs/promises");
const yargs_1 = __importDefault(require("yargs"));
const helpers_1 = require("yargs/helpers");
function codegenContent(schema, document, gqlFile, rawRequest) {
    return `import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
  overwrite: true,
  schema: '${schema}',
  documents: [
    '${document}',
  ],
  generates: {
    '${gqlFile}': {
      plugins: ['typescript', 'typescript-operations', 'typescript-generic-sdk'],
      config: {
        rawRequest: ${rawRequest},
        scalars: {
          BigInt: 'bigint|number',
          Date: 'string',
        },
      },
    },
  },
};
        
export default config;
`;
}
;
async function main() {
    const argv = await (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv))
        .option('url', {
        alias: 'u',
        describe: 'Full GraphQL endpoint URL',
        type: 'string',
    })
        .option('header', {
        alias: 'h',
        describe: 'Optional authentication header for the get-graphql-schema command.',
        type: 'array',
    })
        .option('schema', {
        alias: 's',
        describe: 'Path to save the generated GraphQL schema file.',
        type: 'string',
        default: 'schema.gql',
    })
        .option('gqlDir', {
        alias: 'd',
        describe: 'Path to save the auto generated GraphQL files.',
        type: 'string',
        default: 'gql',
    })
        .option('gqlFile', {
        alias: 'f',
        describe: 'Path to save the auto generated GraphQL queries and mutations and type script types.',
        type: 'string',
        default: 'graphql.ts',
    })
        .option('codegen', {
        alias: 'c',
        describe: 'Path to save the codegen config to for type script types.',
        type: 'string',
        default: 'codegen.ts',
    })
        .option('introspect', {
        alias: 'i',
        describe: 'Turns off auto generation of queries and mutations, for custom queries only.',
        type: 'boolean',
        default: true
    })
        .option('raw', {
        describe: 'Path to save the auto generated GraphQL queries and mutations and type script types.',
        type: 'boolean',
        default: false
    })
        .option('coverage', {
        describe: 'Will add coverage logger to auto-generated client.',
        type: 'boolean',
        default: false
    })
        .version()
        .help()
        .argv;
    if (argv.url) {
        await (0, run_command_1.runCommand)(argv.header ?
            `get-graphql-schema ${argv.url} > ${argv.schema} ${argv.header.map(h => `-h "${h}"`).join(' ')}` :
            `get-graphql-schema ${argv.url} > ${argv.schema}`);
        console.log(`Schema generated from "${argv.url}" to "${argv.schema}".`);
    }
    if (!fs.existsSync(argv.schema)) {
        console.log(`Schema file: "${argv.schema}" was not found.`);
        console.log('Exit with no generated output.');
        return;
    }
    const operationsPath = `${argv.gqlDir}/${argv.introspect ? 'autogenerated-operations' : 'custom-operations'}`;
    if (argv.introspect) {
        await (0, run_command_1.runCommand)(`gqlg --schemaFilePath ${argv.schema} --destDirPath ${operationsPath} --depthLimit 8`);
        console.log(`Operations were generated and saved to "${operationsPath}".`);
    }
    else {
        await (0, promises_1.mkdir)(operationsPath, { recursive: true });
    }
    const codegenDefaultDocument = `${operationsPath}/**/*.gql`;
    const codegenGqlFile = `${argv.gqlDir}/${argv.gqlFile}`;
    if (fs.existsSync(argv.codegen)) {
        const mismatchLogs = [];
        const existingContent = await (0, promises_1.readFile)(argv.codegen, 'utf8');
        const schemaRegex = /\sschema:\s*(['"`])(.+?)\1,/;
        const schemaMatch = existingContent.match(schemaRegex);
        if (schemaMatch) {
            if (schemaMatch[2] !== argv.schema) {
                const updatedContent = existingContent.replace(schemaRegex, ` schema: '${argv.schema}',`);
                await (0, promises_1.writeFile)(argv.codegen, updatedContent, 'utf8');
                console.log(`Updated schema path in "${argv.codegen}".`);
            }
        }
        else {
            mismatchLogs.push(`Could not locate the schema property in "${argv.codegen}".`);
        }
        if (argv.introspect && !existingContent.includes(codegenDefaultDocument)) {
            mismatchLogs.push(`Could not path "${operationsPath}" to autogenerated operations in "${argv.codegen}".`);
        }
        if (!existingContent.includes(codegenGqlFile)) {
            mismatchLogs.push(`Could not locate path to autogenerated graphql types file "${codegenGqlFile}" in "${argv.codegen}".`);
        }
        if (mismatchLogs.length) {
            for (const log of mismatchLogs) {
                console.log(log);
            }
            console.log(`Remove file "${argv.codegen}" to generate new one or fix existing file manually.`);
            return;
        }
    }
    else {
        await (0, promises_1.writeFile)(argv.codegen, codegenContent(argv.schema, codegenDefaultDocument, codegenGqlFile, argv.raw), 'utf8');
        console.log(`File "${argv.codegen}" generated.`);
    }
    if (!argv.introspect) {
        const dir = await (0, promises_1.readdir)(operationsPath, { withFileTypes: true });
        const operations = dir.map(i => i.isFile());
        if (!operations.includes(true)) {
            console.log(`No operations found, API client "${codegenGqlFile}" was not generated, add operations and generate again.`);
            return;
        }
    }
    await (0, run_command_1.runCommand)(`graphql-codegen --config ${argv.codegen}`);
    const [importFragment, getSdkFragment] = argv.coverage ?
        ['getSdkRequester, coverageLogger', 'coverageLogger(getSdk(getSdkRequester(apiContext, options, requestHandler)))'] :
        ['getSdkRequester', 'getSdk(getSdkRequester(apiContext, options, requestHandler))'];
    const graphqlAutogeneratedFileModification = `

// This additional logic appended by playwright-graphql cli to ensure seamless integration
import { ${importFragment} } from 'playwright-graphql';

export type APIRequestContext = Parameters<typeof getSdkRequester>[0];
export type RequesterOptions = Parameters<typeof getSdkRequester>[1] | string;
export type RequestHandler = Parameters<typeof getSdkRequester>[2];

export const getClient = (apiContext: APIRequestContext, options?: RequesterOptions, requestHandler?: RequestHandler) => ${getSdkFragment};

export type GqlAPI = ReturnType<typeof getClient>;

`;
    await (0, promises_1.writeFile)(codegenGqlFile, graphqlAutogeneratedFileModification, { flag: 'a' });
    console.log('Type Script types for Playwright auto generated type safe GQL client generated.');
}
main().catch((err) => {
    console.error(err);
    process.exit(1);
});
