"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const html_generator_1 = require("./html-generator");
const gql_client_parser_1 = require("./gql-client-parser");
const path_1 = require("path");
const consts_1 = require("./consts");
const coverage_calculation_helpers_1 = require("./coverage-calculation-helpers");
function isFileExists(path) {
    return (0, promises_1.access)(path).then(() => true, () => false);
}
class GraphqlCoverageReport {
    operationsSchema;
    logUncoveredOperations = false;
    coverageFilePath;
    htmlFilePath;
    minCoveragePerOperation;
    saveGqlCoverageLog;
    saveHtmlSummary;
    summary = { operationsArgCoverage: [] };
    constructor(options) {
        const absolutePath = (0, path_1.resolve)(options.graphqlFilePath);
        if (!(0, fs_1.existsSync)(absolutePath)) {
            throw new Error(`Source file '${absolutePath}' does not exist.`);
        }
        this.operationsSchema = (0, gql_client_parser_1.extractOperationsInputParamsSchema)(absolutePath);
        this.logUncoveredOperations = options.logUncoveredOperations ?? false;
        this.minCoveragePerOperation = options.minCoveragePerOperation ?? 100;
        this.coverageFilePath = options.coverageFilePath ?? './gql-coverage.log';
        this.htmlFilePath = options.htmlFilePath ?? './gql-coverage.html';
        this.saveGqlCoverageLog = options.saveGqlCoverageLog ?? false;
        this.saveHtmlSummary = options.saveHtmlSummary ?? false;
    }
    async onBegin() {
        if (await isFileExists(consts_1.coverageDir))
            await (0, promises_1.rm)(consts_1.coverageDir, { recursive: true });
        await (0, promises_1.mkdir)(consts_1.coverageDir);
    }
    async onEnd() {
        if (!await isFileExists(consts_1.coverageDir))
            throw new Error(`Directory with logged coverage was not found: ${consts_1.coverageDir}`);
        const operationsFiles = await (0, promises_1.readdir)(consts_1.coverageDir);
        const coveredOperationsWithArgs = await Promise.all(operationsFiles.map(async (fileName) => {
            const operationFile = await (0, promises_1.readFile)((0, path_1.join)(consts_1.coverageDir, fileName), { encoding: 'utf8' });
            return {
                name: fileName,
                calls: JSON.parse(`[${operationFile.slice(0, -1)}]`), // .slice(0, -1) because last char always will be a comma.
            };
        }));
        coveredOperationsWithArgs.forEach((operation) => {
            const operationSchema = this.operationsSchema.find(i => i.name === operation.name);
            if (operationSchema) {
                operation.calls.forEach((i) => {
                    if (i.inputParams.length) {
                        (0, coverage_calculation_helpers_1.incrementCountersInOperationSchema)(operationSchema, i.inputParams);
                    }
                });
            }
        });
        if (await isFileExists(this.coverageFilePath))
            await (0, promises_1.rm)(this.coverageFilePath);
        const coveredInTests = coveredOperationsWithArgs.map(i => i.name);
        for (const operation of this.operationsSchema) {
            const covered = coveredInTests.includes(operation.name);
            const operationCoverage = covered ?
                !operation.inputParams.length ? 100 : (0, coverage_calculation_helpers_1.calculateOperationCoverage)(operation.inputParams) : 0;
            const opCoverageString = `${operationCoverage}%`;
            this.summary.operationsArgCoverage.push({
                name: operation.name,
                argsCoverage: opCoverageString,
                covered: covered ? operationCoverage >= this.minCoveragePerOperation : false
            });
            const argsMap = `(${operation.inputParams.map(param => (0, coverage_calculation_helpers_1.buildParamCoverageString)(param)).join(',\n')});\n`;
            const operationCoverageString = `Args coverage: ${opCoverageString}\n${operation.name} ${argsMap}`;
            if (this.saveGqlCoverageLog)
                await (0, promises_1.writeFile)(this.coverageFilePath, operationCoverageString + '\n', { flag: 'a' });
        }
        this.summary.operationsCoverageSummary = `Total arguments coverage: ${(0, coverage_calculation_helpers_1.calculateTotalArgsCoverage)(this.summary.operationsArgCoverage.map(i => i.argsCoverage))}`;
        if (this.saveGqlCoverageLog)
            await (0, promises_1.writeFile)(this.coverageFilePath, this.summary.operationsCoverageSummary + '\n', { flag: 'a' });
        const coveredOperations = this.summary.operationsArgCoverage
            .filter(i => coveredInTests.includes(i.name) && i.covered).length;
        [this.summary.coverage, this.summary.coverageTotal, this.summary.covered] = [
            `GQL Operations coverage in executed tests: ${(0, coverage_calculation_helpers_1.floorDecimal)((coveredOperations / this.operationsSchema.length) * 100, 2)}%`,
            `Total operations: ${this.operationsSchema.length}`,
            `Covered operations: ${coveredOperations}`,
        ];
        if (this.saveHtmlSummary) {
            await (0, promises_1.writeFile)(this.htmlFilePath, (0, html_generator_1.generateHtmlReport)(this.summary, this.operationsSchema));
        }
        await (0, promises_1.rm)(consts_1.coverageDir, { recursive: true });
    }
    async onExit() {
        console.log('\n' + '='.repeat(170));
        console.log(this.summary.coverage);
        console.log(this.summary.coverageTotal);
        console.log(this.summary.covered);
        console.log(this.summary.operationsCoverageSummary);
        if (this.logUncoveredOperations) {
            console.log('='.repeat(75) + ' Uncovered operations ' + '='.repeat(75));
            console.log(`${this.summary.operationsArgCoverage
                .filter(i => !i.covered)
                .map(({ name, argsCoverage }) => `${name} ${argsCoverage}`)
                .join('\n')}`);
        }
        console.log('='.repeat(170) + '\n');
    }
}
exports.default = GraphqlCoverageReport;
