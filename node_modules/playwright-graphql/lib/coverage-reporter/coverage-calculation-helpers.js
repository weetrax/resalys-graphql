"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.floorDecimal = floorDecimal;
exports.incrementCountersInOperationSchema = incrementCountersInOperationSchema;
exports.calculateOperationCoverage = calculateOperationCoverage;
exports.buildParamCoverageString = buildParamCoverageString;
exports.calculateTotalArgsCoverage = calculateTotalArgsCoverage;
function floorDecimal(value, decimalPlaces) {
    //The multiplier is calculated as 10n, where n is the number of decimal places you want to round to.
    const multiplier = Math.pow(10, decimalPlaces);
    return Math.floor(value * multiplier) / multiplier;
}
function incrementCounterForParamRecursively(paramSchema, inputParam) {
    paramSchema.called++;
    if (paramSchema.subParams && inputParam) {
        Object.keys(inputParam).forEach((key) => {
            const schema = paramSchema.subParams?.find((i) => i.key === key);
            if (schema) {
                incrementCounterForParamRecursively(schema, inputParam[key]);
            }
        });
        return;
    }
    if (paramSchema.enumValues && inputParam) {
        const schema = paramSchema.enumValues.find(i => i.value == inputParam);
        if (schema)
            schema.called++;
    }
}
function incrementCountersInOperationSchema(schema, inputParams) {
    inputParams.forEach((param) => {
        if (param) {
            Object.keys(param).forEach((key) => {
                const paramSchema = schema.inputParams.find(i => i.key === key);
                if (paramSchema) {
                    incrementCounterForParamRecursively(paramSchema, param[key]);
                }
            });
        }
    });
}
function putCoverSign(called) {
    return called > 0 ? '\u2714' : '\u2718'; // mark(✔) and cross(✘) signs
}
function calculateOperationCoverage(params) {
    let totalCoverageItems = 0;
    let coveredItems = 0;
    const incrementation = (i) => {
        totalCoverageItems++;
        if (i.called > 0)
            coveredItems++;
        if (i.subParams) {
            i.subParams.forEach(param => {
                incrementation(param);
            });
        }
        else if (i.enumValues) {
            i.enumValues.forEach(ev => {
                totalCoverageItems++;
                if (ev.called > 0) {
                    coveredItems++;
                }
            });
        }
    };
    params.forEach((i) => incrementation(i));
    if (totalCoverageItems === 0) {
        return 100; // coverage for operations without arguments.
    }
    if (coveredItems > totalCoverageItems) {
        throw new Error('Args coverage calculation has an issue!');
    }
    return floorDecimal((coveredItems / totalCoverageItems) * 100, 2);
}
function buildParamCoverageString(param, indent = '') {
    const currentIndent = indent + '  ';
    let result = `${indent}${param.key} ${putCoverSign(param.called)}`;
    if (param.subParams) {
        result += `: {\n${param.subParams.map(i => buildParamCoverageString(i, currentIndent)).join(',\n')}\n${indent}}`;
    }
    else if (param.enumValues) {
        result += `: [${param.enumValues.map(i => `${i.value} ${putCoverSign(param.called)}`).join(', ')}]`;
    }
    return result;
}
function calculateTotalArgsCoverage(coverageList) {
    let totalCoverage = 0;
    let count = 0;
    for (const coverage of coverageList) {
        const percentageValue = parseFloat(coverage.replace('%', ''));
        totalCoverage += percentageValue;
        count++;
    }
    const totalArgsCoverage = count > 0 ? totalCoverage / count : 0;
    return `${totalArgsCoverage.toFixed(2)}%`;
}
