"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractOperationsInputParamsSchema = extractOperationsInputParamsSchema;
const ts = __importStar(require("typescript"));
function removeOptionalFromKey(key) {
    return key.replace(/\?|\s/g, '');
}
function isTypeCustom(typeString) {
    // all not custom types that can be generated in schema:
    // js primitives including bigint https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures
    // possible custom gql scalar types https://www.apollographql.com/docs/apollo-server/schema/custom-scalars
    // never and function are not in lists but in theory may be generated to I was not able to found any proof of opposite.
    return ![
        'id',
        'null',
        'undefined',
        'string',
        'number',
        'bigint',
        'int',
        'float',
        'boolean',
        'date',
        'function',
        'symbol',
        'never',
        'jsonobject',
        'json',
        'file',
    ].includes(typeString.toLowerCase());
}
function parseTypeStatement(typeStatement) {
    return typeStatement.getText()
        .replace(/.+=|[\n{}]|\/\**.*\//g, '')
        .split(/;/g)
        .filter(i => i)
        .map((i) => {
        const [key, value] = i.trim().split(/:\s/);
        const narrowedTypeString = value.replace(/.+<|>/g, '').replace(/[A-Za-z]+\['|'.+/g, '');
        return {
            key: removeOptionalFromKey(key),
            type: narrowedTypeString,
            called: 0
        };
    });
}
function parseRootInputParamsType(typeString) {
    // regexp was written to parse key value pairs from raw arguments string like:
    // Exact<{ filters?: CoachingRouterPhoneNumberListFilters; skip: number; sort?: CoachingRouterPhoneNumberSortInput; take: number; }>
    // Exact<{ filters: AgentsCallsMetricsListFilters; gradings: CallsGradingsInput; }>
    // Exact<{ params: AppointmentsAggregatedByAgentListArgs; params1: AppointmentsKpIsParams; }>
    const propertyPattern = /(\w+(\?)?|\[\w+:\s\w+])+:\s\w+/g;
    const propStrings = typeString.match(propertyPattern);
    return propStrings ? propStrings.map(p => {
        const [key, type] = p.split(/:\s(?!\w+])/g);
        return { key: removeOptionalFromKey(key), type, called: 0 };
    }) : [];
}
function isEnum(sourceFile, name) {
    return !!sourceFile.statements.find((i) => {
        return ts.isEnumDeclaration(i) && i.name.text === name;
    });
}
function parseEnumStatement(sourceFile, enumName) {
    const enumDeclaration = sourceFile.statements.find((i) => {
        return ts.isEnumDeclaration(i) && i.name.text === enumName;
    });
    if (!enumDeclaration)
        return [];
    return enumDeclaration.getText()
        .replace(/.+{|}/g, '')
        .split(/,/g)
        .filter(i => i)
        .map((i) => {
        const [key, value] = i.trim().split(/=\s/);
        return { key: removeOptionalFromKey(key), value: value.replace(/'/g, ''), called: 0 };
    });
}
function parseCustomType(sourceFile, name) {
    const typeDeclaration = sourceFile.statements.find((i) => {
        return ts.isTypeAliasDeclaration(i) && i.name.text === name;
    });
    if (typeDeclaration) {
        const parsedTypes = parseTypeStatement(typeDeclaration);
        return parsedTypes.map((i) => {
            if (isTypeCustom(i.type)) {
                const custom = isEnum(sourceFile, i.type) ?
                    { enumValues: parseEnumStatement(sourceFile, i.type) } :
                    { subParams: parseCustomType(sourceFile, i.type) };
                return {
                    ...i,
                    ...custom
                };
            }
            return i;
        });
    }
    return [];
}
function extractOperationsInputParamsSchema(absolutePath, sdkFunctionName = 'getSdk') {
    const program = ts.createProgram([absolutePath], { emitDeclarationOnly: true });
    const sourceFile = program.getSourceFile(absolutePath);
    const typeChecker = program.getTypeChecker();
    if (!sourceFile) {
        throw new Error(`Source file '${absolutePath}' not found.`);
    }
    const sdkFunction = sourceFile.statements.find((s) => ts.isFunctionDeclaration(s) && s.name?.text === sdkFunctionName);
    if (!sdkFunction) {
        throw new Error(`Function: '${sdkFunctionName}' not found in file: '${absolutePath}'`);
    }
    const sdkFunctionType = typeChecker.getTypeAtLocation(sdkFunction);
    const returnType = sdkFunctionType.getCallSignatures()[0]?.getReturnType();
    if (!returnType) {
        throw new Error(`The return type of '${sdkFunctionName}' could not be determined.`);
    }
    const operations = typeChecker.getPropertiesOfType(returnType);
    const operationsMap = [];
    for (const operation of operations) { // gql sdk properties loop
        const operationName = operation.getName();
        const propDeclaration = operation.valueDeclaration;
        const operationData = { name: operationName, inputParams: [] };
        if (propDeclaration) {
            const propType = typeChecker.getTypeOfSymbolAtLocation(operation, propDeclaration);
            const signatures = propType.getCallSignatures();
            for (const signature of signatures) { // operations signature extraction loop
                const parameters = signature.getParameters();
                for (const param of parameters) { // operation input parameters loop
                    if (param.getName() !== 'options') {
                        const inputParamsType = typeChecker.getTypeOfSymbolAtLocation(param, param.valueDeclaration);
                        const parsedRootParameters = parseRootInputParamsType(typeChecker.typeToString(inputParamsType));
                        parsedRootParameters.forEach(i => {
                            if (isTypeCustom(i.type)) {
                                const parsedParams = isEnum(sourceFile, i.type) ?
                                    { enumValues: parseEnumStatement(sourceFile, i.type) } :
                                    { subParams: parseCustomType(sourceFile, i.type) };
                                operationData.inputParams?.push({
                                    ...i,
                                    ...parsedParams,
                                });
                            }
                            else if (i.type !== 'never') {
                                operationData.inputParams?.push({
                                    ...i,
                                });
                            }
                        });
                    }
                }
            }
        }
        operationsMap.push(operationData);
    }
    return operationsMap;
}
